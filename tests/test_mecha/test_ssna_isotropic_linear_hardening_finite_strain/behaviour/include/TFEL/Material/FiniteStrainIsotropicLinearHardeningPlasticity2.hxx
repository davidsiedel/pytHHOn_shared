/*!
* \file   TFEL/Material/FiniteStrainIsotropicLinearHardeningPlasticity2.hxx
* \brief  this file implements the FiniteStrainIsotropicLinearHardeningPlasticity2 Behaviour.
*         File generated by tfel version 4.0.0-dev
* \author Thomas Helfer
* \date   09 / 03 / 2021
 */

#ifndef LIB_TFELMATERIAL_FINITESTRAINISOTROPICLINEARHARDENINGPLASTICITY2_HXX
#define LIB_TFELMATERIAL_FINITESTRAINISOTROPICLINEARHARDENINGPLASTICITY2_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/LogarithmicStrainComputeAxialStrainIncrementElasticPrediction.hxx"
#include"TFEL/Material/FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData.hxx"
#include"TFEL/Material/FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData.hxx"

#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorViewIO.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyVectorView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView.hxx"

#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView2.hxx"

#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView2.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorViewIO.hxx"
#include "TFEL/Math/RootFinding/BissectionAlgorithmBase.hxx"
#include "TFEL/Math/AccelerationAlgorithms/AitkenAccelerationAlgorithm.hxx"

#include "MFront/GenericBehaviour/State.hxx"
#include "MFront/GenericBehaviour/BehaviourData.hxx"
namespace tfel{

namespace material{

struct FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer
{
static FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer&
get();


void set(const char* const,const double);

void set(const char* const,const unsigned short);

private :

FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer();

FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer(const FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer&);

FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer&
operator=(const FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(FiniteStrainIsotropicLinearHardeningPlasticity2AxisymmetricalGeneralisedPlaneStressParametersInitializer&,const char* const);
};

struct FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer
{
static FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer&
get();


void set(const char* const,const double);

void set(const char* const,const unsigned short);

private :

FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer();

FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer(const FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer&);

FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer&
operator=(const FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(FiniteStrainIsotropicLinearHardeningPlasticity2PlaneStressParametersInitializer&,const char* const);
};

struct FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer
{
static FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer&
get();

double epsilon;
double theta;
double young;
double nu;
double relative_value_for_the_equivalent_stress_lower_bound;
double ihr_R0_;
double ihr_H_;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer();

FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer(const FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer&);

FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer&
operator=(const FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis,typename Type,bool use_qt>
class FiniteStrainIsotropicLinearHardeningPlasticity2;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2<hypothesis,Type,false>&);

//! \brief forward declaration
template<typename Type>
std::ostream&
 operator <<(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false>&);

//! \brief forward declaration
template<typename Type>
std::ostream&
 operator <<(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::PLANESTRESS,Type,false>&);

/*!
* \class FiniteStrainIsotropicLinearHardeningPlasticity2
* \brief This class implements the FiniteStrainIsotropicLinearHardeningPlasticity2 behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Thomas Helfer
* \date   09 / 03 / 2021
* An implicit implementation of a simple 
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class FiniteStrainIsotropicLinearHardeningPlasticity2<hypothesis,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
static_assert(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false> BehaviourData;
typedef FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



typename tfel::math::StensorFromTinyVectorView<N,1+StensorSize,0,real>::type deel;
real& dp;

bool bpl;
tfel::math::BissectionAlgorithmBase<real> staggered_scheme_bissection_algorithm;
tfel::math::AitkenAccelerationAlgorithm<real> staggered_scheme_aitken_acceleration_algorithm;
stress lambda;
stress mu;
stress young_tdt;
real nu_tdt;
stress lambda_tdt;
stress mu_tdt;

real epsilon;
real theta;
real young;
real nu;
real relative_value_for_the_equivalent_stress_lower_bound;
stress ihr_R0_;
stress ihr_H_;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

// Jacobian
tfel::math::tmatrix<1+StensorSize,1+StensorSize,real> jacobian;
// zeros
tfel::math::tvector<1+StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<1+StensorSize,real> zeros_1;

// function
tfel::math::tvector<1+StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<1+StensorSize,1+StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<1+StensorSize,real> tzeros(this->zeros);
tvector<1+StensorSize,real> tfzeros(this->fzeros);
tmatrix<1+StensorSize,1+StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 1+StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<1+StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 1+StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<1+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<1+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<1+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<1+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<1+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<1+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_p(idx)=vect_e(StensorSize);
}
}

void additionalConvergenceChecks(bool& converged,real& error, const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
if (converged) {
// checking status consistency
if (this->bpl) {
if (this->dp < -2*this->epsilon) {
// desactivating this system
converged = this->bpl = false;
}
} else {
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
if(seq > R) {
converged = false;
this->bpl = true;
}
}
} // end of if(converged)

static_cast<void>(converged);
static_cast<void>(error);
static_cast<void>(smt);
} // end of additionalConvergenceChecks

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda*trace(this->eel+(this->theta)*(this->deel))*Stensor::Id()+2*(this->mu)*(this->eel+(this->theta)*(this->deel));

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda_tdt*trace(this->eel)*Stensor::Id()+2*(this->mu_tdt)*this->eel;

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->p += this->dp;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief return an elastic prediction of the stresses
StressStensor computeElasticPrediction() const{
return this->lambda*trace(this->eel+(this->theta)*(this->deto))*Stensor::Id()+2*(this->mu)*(this->eel+(this->theta)*(this->deto));
}


//! \brief Default constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2() =delete ;
//! \brief Copy constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;
//! \brief Assignement operator (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2& operator = (const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;

public:

/*!
* \brief Constructor
*/
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>& src1,
const FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>& src2)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(src1),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
dp(this->zeros(StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
FiniteStrainIsotropicLinearHardeningPlasticity2(const mfront::gb::BehaviourData& mgb_d)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(mgb_d),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(mgb_d),
deel(this->zeros),
dp(this->zeros(StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.gradients,this->eto.begin());
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.thermodynamic_forces,this->sig.begin());
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
const auto sigel = this->computeElasticPrediction();

const auto& sel = sigel;
const auto seqel = sigmaeq(sel);
const auto Rel = this->ihr_R0_ + (this->ihr_H_)*(this->p);
this->bpl = seqel > Rel;

}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult
computePredictionOperator(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
using std::vector;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid prediction operator flag");
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else {
  return FAILURE;
}return SUCCESS;
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<FiniteStrainIsotropicLinearHardeningPlasticity2::iterMax)){
++(this->iter);
this->computeThermodynamicForces();
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(1+StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<1+StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,1+StensorSize,0,real>::type feel(this->fzeros);
constexpr auto p_offset = StensorSize;
static_cast<void>(p_offset);
real& fp(this->fzeros(StensorSize));
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,1+StensorSize,1+StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// derivative of variable feel by variable p
typename tfel::math::StensorFromTinyMatrixColumnView<N,1+StensorSize,1+StensorSize,
0,StensorSize,real>::type dfeel_ddp(this->jacobian);
// derivative of variable fp by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,1+StensorSize,1+StensorSize,
StensorSize,0,real>::type dfp_ddeel(this->jacobian);
// derivative of variable fp by variable p
real& dfp_ddp = this->jacobian(StensorSize,StensorSize);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=1+StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
feel -= this->deto;

if(this->bpl){
if(!perturbatedSystemEvaluation){
}
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto iseq = 1/max(seq,(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young);
const auto dseq_ds = 3*deviator(s)*(iseq/2);
const auto d2seq_dsds = (Stensor4::M()-(dseq_ds^dseq_ds))*iseq;
const auto& n = dseq_ds;
const auto& dn_ds = d2seq_dsds;
feel += this->dp* n;
dfeel_ddp = n;
dfeel_ddeel += (2 * this->mu)*(this->theta) * ((this->dp) * dn_ds);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
const auto dR_ddp = this->ihr_H_;
fp = (seq-R)/(this->young);
dfp_ddeel += (2 * this->mu)*(this->theta) * (dseq_ds/(this->young));
if(seq<(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young){
if(dR_ddp>0){
dfp_ddp = -1*std::max(real(1.e-12),(dR_ddp)/(this->young));
} else {
dfp_ddp = -1*std::min(-real(1.e-12),(dR_ddp)/(this->young));
}
} else {
dfp_ddp = -(dR_ddp)/(this->young);
}
} // end if(this->bpl)

static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddp); /* suppress potential warnings */
static_cast<void>(dfp_ddeel); /* suppress potential warnings */
static_cast<void>(dfp_ddp); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<1+StensorSize> jacobian_permutation;
TinyMatrixSolve<1+StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(FiniteStrainIsotropicLinearHardeningPlasticity2& b,
const tfel::math::TinyPermutation<1+StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_p);
}
private:
FiniteStrainIsotropicLinearHardeningPlasticity2& behaviour;
const tfel::math::TinyPermutation<1+StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else if (smt==CONSISTENTTANGENTOPERATOR){
  StiffnessTensor Hooke;
  Stensor4 Je;
  computeElasticStiffness<N,Type>::exe(Hooke,this->lambda_tdt,this->mu_tdt);
  getPartialJacobianInvert(Je);
  Dt = Hooke*Je;
} else {
  return false;
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~FiniteStrainIsotropicLinearHardeningPlasticity2()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of FiniteStrainIsotropicLinearHardeningPlasticity2 class

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
operator <<(std::ostream& os,const FiniteStrainIsotropicLinearHardeningPlasticity2<hypothesis,Type,false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "p : " << b.p << '\n';
os << "Δp : " << b.dp << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "staggered_scheme_bissection_algorithm : " << b.staggered_scheme_bissection_algorithm << '\n';
os << "staggered_scheme_aitken_acceleration_algorithm : " << b.staggered_scheme_aitken_acceleration_algorithm << '\n';
os << "ε : " << b.epsilon << '\n';
os << "θ : " << b.theta << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "relative_value_for_the_equivalent_stress_lower_bound : " << b.relative_value_for_the_equivalent_stress_lower_bound << '\n';
os << "ihr_R0_ : " << b.ihr_R0_ << '\n';
os << "ihr_H_ : " << b.ihr_H_ << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* \class FiniteStrainIsotropicLinearHardeningPlasticity2
* \brief This class implements the FiniteStrainIsotropicLinearHardeningPlasticity2 behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Thomas Helfer
* \date   09 / 03 / 2021
* An implicit implementation of a simple 
*/
template<typename Type>
class FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false>{

static constexpr ModellingHypothesis::Hypothesis hypothesis = ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
static_assert(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false> BehaviourData;
typedef FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type deel;
real& dp;
real& detozz;

bool bpl;
tfel::math::BissectionAlgorithmBase<real> staggered_scheme_bissection_algorithm;
tfel::math::AitkenAccelerationAlgorithm<real> staggered_scheme_aitken_acceleration_algorithm;
struct{
stress szz;
stress exp_etozz;
} sebdata;
stress lambda;
stress mu;
stress young_tdt;
real nu_tdt;
stress lambda_tdt;
stress mu_tdt;

real epsilon;
real theta;
real young;
real nu;
real relative_value_for_the_equivalent_stress_lower_bound;
stress ihr_R0_;
stress ihr_H_;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

// Jacobian
tfel::math::tmatrix<2+StensorSize,2+StensorSize,real> jacobian;
// zeros
tfel::math::tvector<2+StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<2+StensorSize,real> zeros_1;

// function
tfel::math::tvector<2+StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<2+StensorSize,2+StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<2+StensorSize,real> tzeros(this->zeros);
tvector<2+StensorSize,real> tfzeros(this->fzeros);
tmatrix<2+StensorSize,2+StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 2+StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<2+StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 2+StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_p(idx)=vect_e(StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_etozz)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_p(idx)=vect_e(StensorSize);
partial_jacobian_etozz(idx)=vect_e(1+StensorSize);
}
}

void additionalConvergenceChecks(bool& converged,real& error, const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
if (converged) {
// checking status consistency
if (this->bpl) {
if (this->dp < -2*this->epsilon) {
// desactivating this system
converged = this->bpl = false;
}
} else {
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
if(seq > R) {
converged = false;
this->bpl = true;
}
}
} // end of if(converged)

static_cast<void>(converged);
static_cast<void>(error);
static_cast<void>(smt);
} // end of additionalConvergenceChecks

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda*trace(this->eel+(this->theta)*(this->deel))*Stensor::Id()+2*(this->mu)*(this->eel+(this->theta)*(this->deel));

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda_tdt*trace(this->eel)*Stensor::Id()+2*(this->mu_tdt)*this->eel;

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->p += this->dp;
this->etozz += this->detozz;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief return an elastic prediction of the stresses
StressStensor computeElasticPrediction() const{
StrainStensor prediction_strain = this->eel+(this->theta)*this->deto;
prediction_strain(1) += (this->theta)*computeAxialStrainIncrementElasticPrediction(this->lambda,2*(this->mu)+this->lambda,this->lambda,this->eel,this->etozz,this->deto,this->sigzz+this->dsigzz,real(1),this->epsilon);
const StressStensor prediction_stress = (this->lambda) * trace(prediction_strain) * Stensor::Id() + 2 * (this->mu) * prediction_strain;
return prediction_stress;
}


//! \brief Default constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2() =delete ;
//! \brief Copy constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;
//! \brief Assignement operator (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2& operator = (const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;

public:

/*!
* \brief Constructor
*/
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>& src1,
const FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>& src2)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(src1),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
dp(this->zeros(StensorSize)),
detozz(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
FiniteStrainIsotropicLinearHardeningPlasticity2(const mfront::gb::BehaviourData& mgb_d)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(mgb_d),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(mgb_d),
deel(this->zeros),
dp(this->zeros(StensorSize)),
detozz(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.gradients,this->eto.begin());
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.thermodynamic_forces,this->sig.begin());
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
const auto sigel = this->computeElasticPrediction();

const auto& sel = sigel;
const auto seqel = sigmaeq(sel);
const auto Rel = this->ihr_R0_ + (this->ihr_H_)*(this->p);
this->bpl = seqel > Rel;

}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult
computePredictionOperator(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
using std::vector;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid prediction operator flag");
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else {
  return FAILURE;
}return SUCCESS;
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<FiniteStrainIsotropicLinearHardeningPlasticity2::iterMax)){
++(this->iter);
this->computeThermodynamicForces();
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(2+StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<2+StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type feel(this->fzeros);
constexpr auto p_offset = StensorSize;
static_cast<void>(p_offset);
real& fp(this->fzeros(StensorSize));
constexpr auto etozz_offset = 1+StensorSize;
static_cast<void>(etozz_offset);
real& fetozz(this->fzeros(1+StensorSize));
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+StensorSize,2+StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// derivative of variable feel by variable p
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,StensorSize,real>::type dfeel_ddp(this->jacobian);
// derivative of variable feel by variable etozz
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,1+StensorSize,real>::type dfeel_ddetozz(this->jacobian);
// derivative of variable fp by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
StensorSize,0,real>::type dfp_ddeel(this->jacobian);
// derivative of variable fp by variable p
real& dfp_ddp = this->jacobian(StensorSize,StensorSize);
// derivative of variable fp by variable etozz
real& dfp_ddetozz = this->jacobian(StensorSize,1+StensorSize);
// derivative of variable fetozz by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
1+StensorSize,0,real>::type dfetozz_ddeel(this->jacobian);
// derivative of variable fetozz by variable p
real& dfetozz_ddp = this->jacobian(1+StensorSize,StensorSize);
// derivative of variable fetozz by variable etozz
real& dfetozz_ddetozz = this->jacobian(1+StensorSize,1+StensorSize);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=2+StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
feel -= this->deto;

this->sebdata.exp_etozz = std::exp(this->etozz+this->detozz);
// the generalised plane stress equation 
// is satisfied at the end of the time step
this->sebdata.szz = 
(this->lambda_tdt+2*(this->mu_tdt))*(this->eel(1)+this->deel(1))+ (this->lambda_tdt)*(this->eel(0)+this->deel(0)+ this->eel(2)+this->deel(2));
fetozz = (this->sebdata.szz-this->sebdata.exp_etozz * (this->sigzz+this->dsigzz))/this->young_tdt;
// modification of the partition of strain
feel(1) -= this->detozz;
// jacobian
dfeel_ddetozz(1) = -1;
dfetozz_ddetozz  = real(0);
dfetozz_ddeel(1) = (this->lambda_tdt+2*(this->mu_tdt))/this->young_tdt;
dfetozz_ddeel(0) = this->lambda_tdt/this->young_tdt;
dfetozz_ddeel(2) = this->lambda_tdt/this->young_tdt;
dfetozz_ddetozz = -this->sebdata.exp_etozz * (this->sigzz+this->dsigzz)/this->young_tdt;

if(this->bpl){
if(!perturbatedSystemEvaluation){
}
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto iseq = 1/max(seq,(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young);
const auto dseq_ds = 3*deviator(s)*(iseq/2);
const auto d2seq_dsds = (Stensor4::M()-(dseq_ds^dseq_ds))*iseq;
const auto& n = dseq_ds;
const auto& dn_ds = d2seq_dsds;
feel += this->dp* n;
dfeel_ddp = n;
dfeel_ddeel += (2 * this->mu)*(this->theta) * ((this->dp) * dn_ds);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
const auto dR_ddp = this->ihr_H_;
fp = (seq-R)/(this->young);
dfp_ddeel += (2 * this->mu)*(this->theta) * (dseq_ds/(this->young));
if(seq<(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young){
if(dR_ddp>0){
dfp_ddp = -1*std::max(real(1.e-12),(dR_ddp)/(this->young));
} else {
dfp_ddp = -1*std::min(-real(1.e-12),(dR_ddp)/(this->young));
}
} else {
dfp_ddp = -(dR_ddp)/(this->young);
}
} // end if(this->bpl)

static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddp); /* suppress potential warnings */
static_cast<void>(dfeel_ddetozz); /* suppress potential warnings */
static_cast<void>(dfp_ddeel); /* suppress potential warnings */
static_cast<void>(dfp_ddp); /* suppress potential warnings */
static_cast<void>(dfp_ddetozz); /* suppress potential warnings */
static_cast<void>(dfetozz_ddeel); /* suppress potential warnings */
static_cast<void>(dfetozz_ddp); /* suppress potential warnings */
static_cast<void>(dfetozz_ddetozz); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<2+StensorSize> jacobian_permutation;
TinyMatrixSolve<2+StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(FiniteStrainIsotropicLinearHardeningPlasticity2& b,
const tfel::math::TinyPermutation<2+StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_p);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_etozz){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_p,
partial_jacobian_etozz);
}
private:
FiniteStrainIsotropicLinearHardeningPlasticity2& behaviour;
const tfel::math::TinyPermutation<2+StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else if (smt==CONSISTENTTANGENTOPERATOR){
  StiffnessTensor Hooke;
  Stensor4 Je;
  computeElasticStiffness<N,Type>::exe(Hooke,this->lambda_tdt,this->mu_tdt);
  getPartialJacobianInvert(Je);
  Dt = Hooke*Je;
} else {
  return false;
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
this->sigzz += this->dsigzz;
}

//!
~FiniteStrainIsotropicLinearHardeningPlasticity2()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of FiniteStrainIsotropicLinearHardeningPlasticity2 class

template<typename Type>
std::ostream&
operator <<(std::ostream& os,const FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "p : " << b.p << '\n';
os << "Δp : " << b.dp << '\n';
os << "etozz : " << b.etozz << '\n';
os << "Δetozz : " << b.detozz << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "sigzz : " << b.sigzz << '\n';
os << "Δsigzz : " << b.dsigzz << '\n';
os << "staggered_scheme_bissection_algorithm : " << b.staggered_scheme_bissection_algorithm << '\n';
os << "staggered_scheme_aitken_acceleration_algorithm : " << b.staggered_scheme_aitken_acceleration_algorithm << '\n';
os << "ε : " << b.epsilon << '\n';
os << "θ : " << b.theta << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "relative_value_for_the_equivalent_stress_lower_bound : " << b.relative_value_for_the_equivalent_stress_lower_bound << '\n';
os << "ihr_R0_ : " << b.ihr_R0_ << '\n';
os << "ihr_H_ : " << b.ihr_H_ << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* \class FiniteStrainIsotropicLinearHardeningPlasticity2
* \brief This class implements the FiniteStrainIsotropicLinearHardeningPlasticity2 behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Thomas Helfer
* \date   09 / 03 / 2021
* An implicit implementation of a simple 
*/
template<typename Type>
class FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::PLANESTRESS,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,ModellingHypothesis::PLANESTRESS,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<ModellingHypothesis::PLANESTRESS,Type,false>,
public FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<ModellingHypothesis::PLANESTRESS,Type,false>{

static constexpr ModellingHypothesis::Hypothesis hypothesis = ModellingHypothesis::PLANESTRESS;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
static_assert(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const FiniteStrainIsotropicLinearHardeningPlasticity2&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false> BehaviourData;
typedef FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type deel;
real& dp;
real& detozz;

bool bpl;
tfel::math::BissectionAlgorithmBase<real> staggered_scheme_bissection_algorithm;
tfel::math::AitkenAccelerationAlgorithm<real> staggered_scheme_aitken_acceleration_algorithm;
struct{
stress szz;
} sebdata;
stress lambda;
stress mu;
stress young_tdt;
real nu_tdt;
stress lambda_tdt;
stress mu_tdt;

real epsilon;
real theta;
real young;
real nu;
real relative_value_for_the_equivalent_stress_lower_bound;
stress ihr_R0_;
stress ihr_H_;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

// Jacobian
tfel::math::tmatrix<2+StensorSize,2+StensorSize,real> jacobian;
// zeros
tfel::math::tvector<2+StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<2+StensorSize,real> zeros_1;

// function
tfel::math::tvector<2+StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<2+StensorSize,2+StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<2+StensorSize,real> tzeros(this->zeros);
tvector<2+StensorSize,real> tfzeros(this->fzeros);
tmatrix<2+StensorSize,2+StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 2+StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<2+StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 2+StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_p(idx)=vect_e(StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_etozz)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_p(idx)=vect_e(StensorSize);
partial_jacobian_etozz(idx)=vect_e(1+StensorSize);
}
}

void additionalConvergenceChecks(bool& converged,real& error, const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
if (converged) {
// checking status consistency
if (this->bpl) {
if (this->dp < -2*this->epsilon) {
// desactivating this system
converged = this->bpl = false;
}
} else {
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
if(seq > R) {
converged = false;
this->bpl = true;
}
}
} // end of if(converged)

static_cast<void>(converged);
static_cast<void>(error);
static_cast<void>(smt);
} // end of additionalConvergenceChecks

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda*trace(this->eel+(this->theta)*(this->deel))*Stensor::Id()+2*(this->mu)*(this->eel+(this->theta)*(this->deel));

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->sig=this->lambda_tdt*trace(this->eel)*Stensor::Id()+2*(this->mu_tdt)*this->eel;

} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->p += this->dp;
this->etozz += this->detozz;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief return an elastic prediction of the stresses
StressStensor computeElasticPrediction() const{
StressStensor prediction_stress;
StressStensor prediction_strain = this->eel+(this->theta)*this->deto;
prediction_stress(0) = 2*(this->mu)*((this->lambda)/(this->lambda+2*(this->mu))*(prediction_strain(0)+prediction_strain(1))+prediction_strain(0));
prediction_stress(1) = 2*(this->mu)*((this->lambda)/(this->lambda+2*(this->mu))*(prediction_strain(0)+prediction_strain(1))+prediction_strain(1));
prediction_stress(3) = 2*(this->mu)*prediction_strain(3);
prediction_stress(2) = stress(0);
return prediction_stress;
}


//! \brief Default constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2() =delete ;
//! \brief Copy constructor (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;
//! \brief Assignement operator (disabled)
FiniteStrainIsotropicLinearHardeningPlasticity2& operator = (const FiniteStrainIsotropicLinearHardeningPlasticity2&) = delete;

public:

/*!
* \brief Constructor
*/
FiniteStrainIsotropicLinearHardeningPlasticity2(const FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>& src1,
const FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>& src2)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(src1),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
dp(this->zeros(StensorSize)),
detozz(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
FiniteStrainIsotropicLinearHardeningPlasticity2(const mfront::gb::BehaviourData& mgb_d)
: FiniteStrainIsotropicLinearHardeningPlasticity2BehaviourData<hypothesis,Type,false>(mgb_d),
FiniteStrainIsotropicLinearHardeningPlasticity2IntegrationData<hypothesis,Type,false>(mgb_d),
deel(this->zeros),
dp(this->zeros(StensorSize)),
detozz(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().epsilon;
this->theta = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().theta;
this->young = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().young;
this->nu = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().nu;
this->relative_value_for_the_equivalent_stress_lower_bound = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().relative_value_for_the_equivalent_stress_lower_bound;
this->ihr_R0_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_R0_;
this->ihr_H_ = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().ihr_H_;
this->minimal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = FiniteStrainIsotropicLinearHardeningPlasticity2ParametersInitializer::get().iterMax;
this->lambda=computeLambda(young,nu);
this->mu=computeMu(young,nu);
this->young_tdt  = this->young;
this->nu_tdt     = this->nu;
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.gradients,this->eto.begin());
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.thermodynamic_forces,this->sig.begin());
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
const auto sigel = this->computeElasticPrediction();

const auto& sel = sigel;
const auto seqel = sigmaeq(sel);
const auto Rel = this->ihr_R0_ + (this->ihr_H_)*(this->p);
this->bpl = seqel > Rel;

}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult
computePredictionOperator(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
using std::vector;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid prediction operator flag");
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else {
  return FAILURE;
}return SUCCESS;
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<FiniteStrainIsotropicLinearHardeningPlasticity2::iterMax)){
++(this->iter);
this->computeThermodynamicForces();
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(2+StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<2+StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of FiniteStrainIsotropicLinearHardeningPlasticity2::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type feel(this->fzeros);
constexpr auto p_offset = StensorSize;
static_cast<void>(p_offset);
real& fp(this->fzeros(StensorSize));
constexpr auto etozz_offset = 1+StensorSize;
static_cast<void>(etozz_offset);
real& fetozz(this->fzeros(1+StensorSize));
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+StensorSize,2+StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// derivative of variable feel by variable p
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,StensorSize,real>::type dfeel_ddp(this->jacobian);
// derivative of variable feel by variable etozz
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,1+StensorSize,real>::type dfeel_ddetozz(this->jacobian);
// derivative of variable fp by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
StensorSize,0,real>::type dfp_ddeel(this->jacobian);
// derivative of variable fp by variable p
real& dfp_ddp = this->jacobian(StensorSize,StensorSize);
// derivative of variable fp by variable etozz
real& dfp_ddetozz = this->jacobian(StensorSize,1+StensorSize);
// derivative of variable fetozz by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
1+StensorSize,0,real>::type dfetozz_ddeel(this->jacobian);
// derivative of variable fetozz by variable p
real& dfetozz_ddp = this->jacobian(1+StensorSize,StensorSize);
// derivative of variable fetozz by variable etozz
real& dfetozz_ddetozz = this->jacobian(1+StensorSize,1+StensorSize);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=2+StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
feel -= this->deto;

// the plane stress equation is satisfied at the end of the time step
this->sebdata.szz = (this->lambda_tdt+2*(this->mu_tdt))*(this->eel(2)+this->deel(2))+                   (this->lambda_tdt)*(this->eel(0)+this->deel(0)+this->eel(1)+this->deel(1));
fetozz   = this->sebdata.szz/(this->young_tdt);
// modification of the partition of strain
feel(2) -= detozz;
// jacobian
dfeel_ddetozz(2) = -1;
dfetozz_ddetozz  = real(0);
dfetozz_ddeel(2) = (this->lambda_tdt+2*(this->mu_tdt))/this->young_tdt;
dfetozz_ddeel(0) = this->lambda_tdt/this->young_tdt;
dfetozz_ddeel(1) = this->lambda_tdt/this->young_tdt;

if(this->bpl){
if(!perturbatedSystemEvaluation){
}
const auto& s = this->sig;
const auto seq = sigmaeq(s);
const auto iseq = 1/max(seq,(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young);
const auto dseq_ds = 3*deviator(s)*(iseq/2);
const auto d2seq_dsds = (Stensor4::M()-(dseq_ds^dseq_ds))*iseq;
const auto& n = dseq_ds;
const auto& dn_ds = d2seq_dsds;
feel += this->dp* n;
dfeel_ddp = n;
dfeel_ddeel += (2 * this->mu)*(this->theta) * ((this->dp) * dn_ds);
const auto R = this->ihr_R0_ + (this->ihr_H_)*(this->p+(this->theta)*(this->dp));
const auto dR_ddp = this->ihr_H_;
fp = (seq-R)/(this->young);
dfp_ddeel += (2 * this->mu)*(this->theta) * (dseq_ds/(this->young));
if(seq<(this->relative_value_for_the_equivalent_stress_lower_bound) * this->young){
if(dR_ddp>0){
dfp_ddp = -1*std::max(real(1.e-12),(dR_ddp)/(this->young));
} else {
dfp_ddp = -1*std::min(-real(1.e-12),(dR_ddp)/(this->young));
}
} else {
dfp_ddp = -(dR_ddp)/(this->young);
}
} // end if(this->bpl)

static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddp); /* suppress potential warnings */
static_cast<void>(dfeel_ddetozz); /* suppress potential warnings */
static_cast<void>(dfp_ddeel); /* suppress potential warnings */
static_cast<void>(dfp_ddp); /* suppress potential warnings */
static_cast<void>(dfp_ddetozz); /* suppress potential warnings */
static_cast<void>(dfetozz_ddeel); /* suppress potential warnings */
static_cast<void>(dfetozz_ddp); /* suppress potential warnings */
static_cast<void>(dfetozz_ddetozz); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<2+StensorSize> jacobian_permutation;
TinyMatrixSolve<2+StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(FiniteStrainIsotropicLinearHardeningPlasticity2& b,
const tfel::math::TinyPermutation<2+StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_p);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_p,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_etozz){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_p,
partial_jacobian_etozz);
}
private:
FiniteStrainIsotropicLinearHardeningPlasticity2& behaviour;
const tfel::math::TinyPermutation<2+StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Dt,this->lambda_tdt,this->mu_tdt);
} else if (smt==CONSISTENTTANGENTOPERATOR){
  StiffnessTensor Hooke;
  Stensor4 Je;
  computeElasticStiffness<N,Type>::exe(Hooke,this->lambda_tdt,this->mu_tdt);
  getPartialJacobianInvert(Je);
  Dt = Hooke*Je;
} else {
  return false;
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~FiniteStrainIsotropicLinearHardeningPlasticity2()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of FiniteStrainIsotropicLinearHardeningPlasticity2 class

template<typename Type>
std::ostream&
operator <<(std::ostream& os,const FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::PLANESTRESS,Type,false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "p : " << b.p << '\n';
os << "Δp : " << b.dp << '\n';
os << "etozz : " << b.etozz << '\n';
os << "Δetozz : " << b.detozz << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "staggered_scheme_bissection_algorithm : " << b.staggered_scheme_bissection_algorithm << '\n';
os << "staggered_scheme_aitken_acceleration_algorithm : " << b.staggered_scheme_aitken_acceleration_algorithm << '\n';
os << "ε : " << b.epsilon << '\n';
os << "θ : " << b.theta << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "relative_value_for_the_equivalent_stress_lower_bound : " << b.relative_value_for_the_equivalent_stress_lower_bound << '\n';
os << "ihr_R0_ : " << b.ihr_R0_ << '\n';
os << "ihr_H_ : " << b.ihr_H_ << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for FiniteStrainIsotropicLinearHardeningPlasticity2.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MechanicalBehaviourTraits<FiniteStrainIsotropicLinearHardeningPlasticity2<hypothesis,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 1+StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = true;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "FiniteStrainIsotropicLinearHardeningPlasticity2";
}

};

/*!
* Partial specialisation for FiniteStrainIsotropicLinearHardeningPlasticity2.
*/
template<typename Type>
class MechanicalBehaviourTraits<FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 2+StensorSize;
static constexpr unsigned short external_variables_nb  = 2;
static constexpr unsigned short external_variables_nb2 = 1;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = true;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "FiniteStrainIsotropicLinearHardeningPlasticity2";
}

};

/*!
* Partial specialisation for FiniteStrainIsotropicLinearHardeningPlasticity2.
*/
template<typename Type>
class MechanicalBehaviourTraits<FiniteStrainIsotropicLinearHardeningPlasticity2<ModellingHypothesis::PLANESTRESS,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<ModellingHypothesis::PLANESTRESS>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 2+StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = true;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "FiniteStrainIsotropicLinearHardeningPlasticity2";
}

};

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_FINITESTRAINISOTROPICLINEARHARDENINGPLASTICITY2_HXX */
